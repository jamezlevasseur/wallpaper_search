package wallpaper_search;
import java.awt.Color;
import java.io.Serializable;


public class ColorMap implements Serializable {

	private static final long serialVersionUID = 435662231;
	private ColorDataPair[][][] hsb;
	public String dir;
	private final static int ARRAY_SIZE = 101;
	
	public ColorMap () {
		hsb = new ColorDataPair[ARRAY_SIZE][ARRAY_SIZE][ARRAY_SIZE];
	}
	
	/**
	 * Inserts a value into the ColorMap in a null spot or adds wallpapers
	 * to existing object.
	 * @param ins - the object attempting to insert
	 * @return the object that now contains the wallpapers of ins
	 */
	public ColorDataPair insert (ColorDataPair ins) {
		int[] indexes = getIndexesForHex(ins.getHex());
		if (hsb[indexes[0]][indexes[1]][indexes[2]]==null) {
			hsb[indexes[0]][indexes[1]][indexes[2]] = ins;
			return ins;
		} else {
			for (Wallpaper wp: ins.getWallpapers())
				hsb[indexes[0]][indexes[1]][indexes[2]].addWallpaper(wp);
			return hsb[indexes[0]][indexes[1]][indexes[2]];
		}
	}
	
	/**
	 * Attempts to find a ColorDataPair object in the ColorMap
	 * @param find - the object being searched for, search specifically for the hex value
	 * @return the object with hex value matching find or null
	 */
	public ColorDataPair find (ColorDataPair find) {
		int[] indexes = getIndexesForHex(find.getHex());
		if (hsb[indexes[0]][indexes[1]][indexes[2]]!=null) {
			return hsb[indexes[0]][indexes[1]][indexes[2]];
		}
		return null;
	}
	
	/**
	 * Attempts to find colors similar to find, within a range of tolerance
	 * @param find - The ColorDataPair to base the search off of
	 * @param tolerance - int value that determines how similar a color needs to be
	 * in order to be returned. Low value requiring high similarity, high opposite.
	 * tolerance > 0
	 * @return an array, potentially empty, of ColorDataPair objects deemed similar to find
	 */
	public ColorDataPair[] findLikeColors (ColorDataPair find, int tolerance) {
		/**
		 * The equation for finding similar colors is based off of finding similarities
		 * on three different aspects of the color: hue saturation and brightness.
		 * 2+tolerance*2 - this part represents the number of hue values that potentially
		 * may be found similar, larger range is given to hue than the other two factors.
		 * 
		 * 2+tolerance - this part of the equation refers to saturation, and brightness
		 * 
		 * These two equations are essentially just calculating what range of indexes around the
		 * indexes generated by find are acceptably similar
		 */
		int size = (int) ( (int)(2+tolerance*2) * Math.pow( (2+tolerance), 2) );
		ColorDataPair[] results = new ColorDataPair[ size ];
		int index = 0;
		int[] indexes = getIndexesForHex(find.getHex());
		//System.out.println("find hex: "+find.getHex());
		//System.out.println("find indexes: "+indexes[0]+" "+indexes[1]+" "+indexes[2]);
		
		//starting index for hue
		int hueIndex = (indexes[0]-tolerance) < 0 ?
								(indexes[0]-tolerance)+(ARRAY_SIZE-1) 
									:(indexes[0]-tolerance) ;
		//termination value for hue
		int hueTerminate = indexes[0]+tolerance+1 > ARRAY_SIZE-1 ?
								(indexes[0]+tolerance)-ARRAY_SIZE 
									:indexes[0]+tolerance+1 ;
		//starting index for saturation and brightness
		int lowerIndex = (indexes[1]-tolerance/2) < 0 ? 
								(indexes[1]-tolerance/2)+(ARRAY_SIZE-1) 
									:(indexes[1]-tolerance/2) ;
		
		//hue is a radial value such as colors on a color wheel and must be cycled 
		//thusly needs a pre-determined termination index as it may start at 97
		//and need to end at 3
		for (int h=hueIndex; h!=hueTerminate; h++ ) {
			h = h==ARRAY_SIZE ? 0 : h;
			for (int s=lowerIndex; s<ARRAY_SIZE; s++ ) {
				for (int b=lowerIndex; b<ARRAY_SIZE; b++ ) {
					//System.out.println("h: "+h+" s: "+s+" b: "+b);
					if (hsb[h][s][b] != null) {
						System.out.println("ADDED");
						System.out.println(hsb[h][s][b]);
						results[index] = hsb[h][s][b];
						index++;
					}
				}
			}
		}
		ColorDataPair[] returnableResults = new ColorDataPair[index];
		for (int i=0; i<returnableResults.length; i++)
			returnableResults[i] = results[i];
		return returnableResults;
	}
	
	/**
	 * determines if color1 is similar enough to color2 based on tolerance
	 * @param color1 - first color to compare
	 * @param color2 - second color to compare
	 * @param tolerance - value that will determine similarity goals
	 * @return true if colors are similar enough, false otherwise
	 */
	public static boolean isLikeColor (ColorDataPair color1, ColorDataPair color2, int tolerance) {
		int[] cindexes1 = getIndexesForHex(color1.getHex());
		int[] cindexes2 = getIndexesForHex(color2.getHex());
		for (int i=0; i<cindexes1.length; i++) {
			if (Math.abs(cindexes1[i]-cindexes2[i])>tolerance)
				return false;
		}
		return true;
	}
	
	/**
	 * determines if color1 is similar enough to color2 based on tolerance
	 * this version converts the hex strings to ColorDataPairs internally
	 * @param color1 - first color to compare, must be a hex string
	 * @param color2 - second color to compare, must be a hex string
	 * @param tolerance - value that will determine similarity goals
	 * @return true if colors are similar enough, false otherwise
	 */
	public static boolean isLikeColor (String color1, String color2, int tolerance) {
		ColorDataPair first = new ColorDataPair(color1);
		ColorDataPair second = new ColorDataPair(color2);
		
		int[] cindexes1 = getIndexesForHex(first.getHex());
		int[] cindexes2 = getIndexesForHex(second.getHex());
		for (int i=0; i<cindexes1.length; i++) {
			if (Math.abs(cindexes1[i]-cindexes2[i])>tolerance)
				return false;
		}
		return true;
	}
	
	/**
	 * Gets the indexes for a 6 length color hex value based on hue, saturation, and brightness.
	 * @param hex - the hex to use for the indexes
	 * @return an array of ints that can be used to store a value in ColorMaps hsb array
	 */
	private static int[] getIndexesForHex (String hex) {
		
		int red = Integer.parseInt( hex.substring(0, 2), 16);
		int green = Integer.parseInt( hex.substring(2, 4), 16);
		int blue = Integer.parseInt( hex.substring(4, 6), 16);
		float[] convert = Color.RGBtoHSB(red, green, blue, null);
		int[] indexes =
				new int[] {
						(int) (convert[0]*100),
						(int) (convert[1]*100),
						(int) (convert[2]*100)
				};
		return indexes;
	}
	
}
